#!/usr/bin/env python3
# /// script
# requires-python = ">=3.12"
# dependencies = [
#   "vsjetpack",
#   "numpy",
# ]
# ///

# Requires manually installing:
# Av1an:             Native Windows Version (in VapourSynth folder)
# SVT-AV1:           Native Windows Version
# FFmpeg:            Windows version
# fssimu2:           Native Windows Version (in tools folder) for metrics

# Auto-Boost-Essential (Native Windows Edition)
# Modified for Native Av1an + Standard SVT-AV1 flow + fssimu2 + Zones Support

from vstools import vs, core, depth, DitherType, clip_async_render

try:
    from vstools.functions.progress import get_render_progress, FPSColumn
except:
    from vstools.functions.render.progress import get_render_progress, FPSColumn
from rich.progress import (
    Progress,
    TextColumn,
    BarColumn,
    TimeElapsedColumn,
    TimeRemainingColumn,
    SpinnerColumn,
)
from rich.console import Console
from statistics import quantiles
from math import ceil, log10
from pathlib import Path
import subprocess
import argparse
import platform
import shutil
import struct
import glob
import sys
import gc
import os
import re
import json
import numpy as np
import concurrent.futures

ver_str = "v2.9.11 (Fix SSIMU2 Fallback Format ID)"

# --- TOOL PATHS CONFIGURATION ---
# Resolved to absolute paths immediately to prevent issues when subprocess changes cwd
if platform.system() == "Windows":
    av1an_exe = Path(r"tools\av1an\av1an.exe").resolve()
    fssimu2_exe = Path(r"tools\fssimu2\fssimu2.exe").resolve()
else:
    # On Linux, assume tools are in PATH
    av1an_path = shutil.which("av1an")
    fssimu2_path = shutil.which("fssimu2")

    av1an_exe = Path(av1an_path) if av1an_path else Path("av1an")
    fssimu2_exe = Path(fssimu2_path) if fssimu2_path else Path("fssimu2")
# --------------------------------

parser = argparse.ArgumentParser()
parser.add_argument(
    "-s",
    "--stage",
    help="Select stage: 1 = fast encode, 2 = calculate metrics, 3 = generate zones, 4 = final encode | Default: all",
    default=0,
)
parser.add_argument(
    "-i", "--input", required=True, help="Video input filepath (original source file)"
)
parser.add_argument(
    "--scenes",
    help="Path to external scenes JSON generated by Progressive-Scene-Detection",
)
parser.add_argument(
    "-t",
    "--temp",
    help="The temporary directory for the script to store files in | Default: video input filename",
)
parser.add_argument(
    "--fast-speed",
    help="Fast encode speed (Allowed: 0-10 or presets) | Default: 10",
    default="10",
)
parser.add_argument(
    "--final-speed",
    help="Final encode speed (Allowed: 0-10 or presets) | Default: 4",
    default="4",
)
parser.add_argument(
    "--quality",
    help="Base encoder --quality (Allowed: low, medium, high, breeze or int) | Default: medium",
    default="medium",
)
parser.add_argument(
    "-a",
    "--aggressive",
    action="store_true",
    help="More aggressive boosting | Default: not active",
)
parser.add_argument(
    "-u",
    "--unshackle",
    action="store_true",
    help="Less restrictive boosting | Default: not active",
)
parser.add_argument("--fast-params", help="Custom fast encoding parameters (SVT flags)")
parser.add_argument(
    "--final-params",
    help="Custom final encoding parameters (SVT flags passed to Av1an)",
)
parser.add_argument(
    "--ssimu2",
    nargs="?",
    const="auto",
    choices=["auto", "cpu", "gpu"],
    help="SSIMU2 mode: Uses fssimu2 binary (choices are kept for compatibility but all map to fssimu2)",
)
parser.add_argument(
    "--workers", help="Number of Av1an workers | Default: 1", default="1"
)
parser.add_argument(
    "--photon-noise", help="Photon noise strength | Default: 2", default="2"
)
parser.add_argument(
    "--verbose", action="store_true", help="Enable more verbosity | Default: not active"
)
parser.add_argument(
    "-r",
    "--resume",
    action="store_true",
    help="Resume the process from the last (un)completed stage | Default: not active",
)
parser.add_argument(
    "-nb",
    "--no-boosting",
    action="store_true",
    help="Runs the script without boosting (final encode only) | Default: not active",
)
parser.add_argument(
    "--autocrop",
    action="store_true",
    help="Enable automatic crop detection | Default: not active",
)
parser.add_argument(
    "-v", "--version", action="version", version=f"Auto-Boost-Essential {ver_str}"
)
parser.add_argument(
    "--debug",
    action="store_true",
    help="Checks the installation and provides relevant information for troubleshooting | Default: not active",
)

args = parser.parse_args()

stage = int(args.stage)
src_file = Path(args.input).resolve()
if platform.system() == "Windows":
    src_file = type(src_file)(r"\\?" + rf"\{src_file}")
file_ext = src_file.suffix
output_dir = src_file.parent
if args.temp is not None:
    tmp_dir = Path(args.temp).resolve()
    if platform.system() == "Windows":
        tmp_dir = type(tmp_dir)(r"\\?" + rf"\{tmp_dir}")
else:
    tmp_dir = output_dir / src_file.stem

# Files
vpy_file = tmp_dir / f"{src_file.stem}.vpy"
cache_file = tmp_dir / f"{src_file.stem}.ffindex"
# Fast pass is now MKV
fast_output_file = tmp_dir / f"{src_file.stem}_fastpass.mkv"
# Final output
final_output_file = output_dir / f"{src_file.stem}-av1.mkv"
tmp_final_output_file = tmp_dir / f"{src_file.stem}-av1.mkv"

ssimu2_log_file = tmp_dir / f"{src_file.stem}_ssimu2.log"
xpsnr_log_file = tmp_dir / f"{src_file.stem}_xpsnr.log"
scenes_file = tmp_dir / f"{src_file.stem}_scenes.json"
stage_file = tmp_dir / f"{src_file.stem}_stage.txt"
stage_resume = 0

# Handle external scenes path
external_scenes_file = None
if args.scenes:
    external_scenes_file = Path(args.scenes).resolve()
    if not external_scenes_file.exists():
        print(
            f"Warning: External scenes file {external_scenes_file} not found. Will fallback to internal detection."
        )
        external_scenes_file = None

# Speed Mapping
speed_map = {
    "slower": "2",
    "slow": "4",
    "medium": "6",
    "fast": "8",
    "faster": "10",
    "0": "0",
}

fast_speed = str(args.fast_speed)
if fast_speed.lower() in speed_map:
    fast_speed = speed_map[fast_speed.lower()]

final_speed = str(args.final_speed)
if final_speed.lower() in speed_map:
    final_speed = speed_map[final_speed.lower()]

quality = args.quality
aggressive = args.aggressive
unshackle = args.unshackle
fast_params = args.fast_params if args.fast_params is not None else ""
final_params = args.final_params if args.final_params is not None else ""
ssimu2 = args.ssimu2 if args.ssimu2 is not None else ""
verbose = args.verbose
resume = args.resume
no_boosting = args.no_boosting
av1an_workers = args.workers
photon_noise_val = int(args.photon_noise)

if args.debug:
    print("=" * 54)
    print("SYSTEM INFORMATION")
    print("=" * 54)
    print(f"System: {platform.platform()}")
    print(f"Python Version: {sys.version}")
    print("=" * 54)
    print("Check for Tools")
    print("=" * 54)
    print(f"Av1an Path:   {av1an_exe}")
    print(f"Av1an Exists: {av1an_exe.exists()}")
    print(f"fssimu2 Path:   {fssimu2_exe}")
    print(f"fssimu2 Exists: {fssimu2_exe.exists()}")
    raise SystemExit(1)

if not os.path.exists(src_file):
    print("The source input doesn't exist. Double-check the provided path.")
    raise SystemExit(1)

if "--preset" in fast_params.split():
    print("Please use --fast-speed argument instead of putting --preset in fast-params")
    raise SystemExit(1)

if "--crf" in fast_params:
    index = fast_params.index("--crf")
    try:
        quality = float(fast_params[index + 6 : index + 11])
    except:
        try:
            quality = float(fast_params[index + 6 : index + 10])
        except:
            try:
                quality = float(fast_params[index + 6 : index + 8])
            except:
                print("CRF must have 0, 1 or 2 decimals.")
                raise SystemExit(1)
else:
    if quality not in ["low", "medium", "high", "breeze"]:
        try:
            float(quality)
        except ValueError:
            print(
                "The quality preset must be either low, medium, high, breeze or a number."
            )
            raise SystemExit(1)

if stage != 0 and resume:
    print(
        "Resume will auto-resume from the last (un)completed stage. You cannot provide both stage and resume."
    )
    raise SystemExit(1)

if os.path.exists(tmp_dir):
    if resume and os.path.exists(stage_file):
        with open(stage_file, "r") as file:
            lines = file.readlines()
            stage_resume = int(lines[0].strip())
            if stage_resume == 5:
                print("Final encode already finished. Nothing to resume.")
                raise SystemExit(0)
            else:
                print(f"Resuming from stage {stage_resume}.")

    if not resume and stage in [0, 1]:
        shutil.rmtree(tmp_dir)

if not os.path.exists(tmp_dir):
    os.makedirs(tmp_dir)

core.max_cache_size = 1024
console = Console()


def detect_crop_values(source_path: Path) -> tuple[int, int]:
    """
    Detects crop values using ffmpeg at the 15-minute mark for 50 frames.
    Returns (crop_top, crop_bottom).
    """
    if verbose:
        console.print("[yellow]Detecting crop values...[/yellow]")

    if shutil.which("ffmpeg") is None:
        console.print(
            "[red]FFmpeg not found! Cannot detect crop. Proceeding with 0 crop.[/red]"
        )
        return 0, 0

    cmd = [
        "ffmpeg",
        "-ss",
        "900",  # 15 minutes
        "-i",
        str(source_path),
        "-vframes",
        "50",
        "-vf",
        "cropdetect=24:16:0",
        "-f",
        "null",
        "-",
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True)
        matches = re.findall(r"crop=(\d+):(\d+):(\d+):(\d+)", result.stderr)
        if not matches:
            if verbose:
                console.print("[yellow]No crop detected or full frame.[/yellow]")
            return 0, 0

        from collections import Counter

        most_common = Counter(matches).most_common(1)[0][0]
        w, h, x, y = map(int, most_common)

        probe_cmd = [
            "ffprobe",
            "-v",
            "error",
            "-select_streams",
            "v:0",
            "-show_entries",
            "stream=height",
            "-of",
            "csv=s=x:p=0",
            str(source_path),
        ]
        probe_res = subprocess.run(probe_cmd, capture_output=True, text=True)
        orig_h = int(probe_res.stdout.strip())

        crop_top = y
        crop_bottom = orig_h - (y + h)

        if crop_top % 2 != 0:
            crop_top -= 1
        if crop_bottom % 2 != 0:
            crop_bottom -= 1

        if verbose:
            console.print(
                f"[green]Detected Crop - Top: {crop_top}, Bottom: {crop_bottom}[/green]"
            )

        return crop_top, crop_bottom

    except Exception as e:
        console.print(f"[red]Error detecting crop: {e}. Defaulting to 0.[/red]")
        return 0, 0


# Generate VPY file
if not os.path.exists(vpy_file):
    crop_top, crop_bottom = 0, 0
    if args.autocrop:
        crop_top, crop_bottom = detect_crop_values(src_file)

    # Template
    vpy_template = """
from vstools import vs, core, depth, DitherType, set_output
core.max_cache_size = 1024
src = core.ffms2.Source(source=r"{source}", cachefile=r"{cache}")

if {ct} > 0 or {cb} > 0:
    src = src.std.Crop(top={ct}, bottom={cb})

bit_to_format = {{
    8: vs.YUV420P8,
    10: vs.YUV420P10,
    12: vs.YUV420P12
}}
bit_to_dither = {{
    8: DitherType.NONE,
    10: DitherType.NONE,
    12: DitherType.AUTO
}}
fmt = bit_to_format.get(src.format.bits_per_sample, vs.YUV420P16)
dt = bit_to_dither.get(src.format.bits_per_sample, DitherType.AUTO)
src = depth(src.resize.Bilinear(format=fmt), 10, dither_type=dt)
set_output(src)
"""

    # Write Windows VPY (Absolute paths okay here for local python)
    with open(vpy_file, "w") as file:
        file.write(
            vpy_template.format(
                source=src_file, cache=cache_file, ct=crop_top, cb=crop_bottom
            )
        )


def get_file_info(
    vfile: Path, mode: str
) -> tuple[list[int], bool, int, int, int, int, int]:
    if mode == "src":
        kf_file = tmp_dir / "info_src.txt"
    else:
        kf_file = tmp_dir / "info.txt"

    if kf_file.exists() and mode == "src" and (stage != 0 or resume):
        with open(kf_file, "r") as file:
            print("Loading cached scene information...")
            lines = file.readlines()
            return (
                [int(line.strip()) for line in lines[1:-3]],
                lines[0].strip() == "True",
                int(lines[-5].strip()),
                int(lines[-4].strip()),
                int(lines[-3].strip()),
                int(lines[-2].strip()),
                int(lines[-1].strip()),
            )

    # Setup VPY environment to get src info from Windows VPY
    vpy_vars = {}
    exec(open(vpy_file).read(), globals(), vpy_vars)

    if mode == "src":
        src = vpy_vars["src"]
    else:
        # For encoded file (MKV/IVF), we use FFMS2
        src = core.ffms2.Source(source=vfile, cache=False)

    nframe = len(src)
    if mode == "len":
        return 0, 0, nframe, 0, 0, 0, 0

    fwidth, fheight = src.width, src.height
    hr = fwidth * fheight > 1920 * 1080
    with open(kf_file, "w") as file:
        file.write(str(hr) + "\n")

    ffpsnum = src.fps.numerator
    ffpsden = src.fps.denominator

    iframe_list = []

    # If external scenes are provided, use them instead of scanning
    if mode == "src" and external_scenes_file is not None:
        console.print(
            f"[green]Using external scenes: {external_scenes_file.name}[/green]"
        )
        try:
            with open(external_scenes_file, "r") as f:
                scene_data = json.load(f)
            # Progressive-Scene-Detection outputs "scenes" list with "start_frame"
            if "scenes" in scene_data:
                for s in scene_data["scenes"]:
                    iframe_list.append(s["start_frame"])
            else:
                console.print(
                    "[red]Invalid external scenes JSON format. Falling back to detection.[/red]"
                )
                # Fallback logic handled below by checking if iframe_list is empty
        except Exception as e:
            console.print(
                f"[red]Error reading external scenes: {e}. Falling back to detection.[/red]"
            )

    if mode == "src" and not iframe_list:
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            "[progress.percentage]{task.percentage:>3.0f}%",
            FPSColumn(),
            TimeElapsedColumn(),
            TimeRemainingColumn(),
            console=console,
        ) as progress:
            task = progress.add_task("[green]Analyzing Scenes (SCDetect)", total=nframe)

            def progress_func(n: int, num_frames: int) -> None:
                progress.update(task, completed=n)

            # Create a lightweight analysis clip (360p, 8-bit) for fast SCDetect
            analysis_clip = src.resize.Bilinear(640, 360, format=vs.YUV420P8)
            analysis_clip = analysis_clip.misc.SCDetect(threshold=0.1)

            def get_props(n: int, f: vs.VideoFrame) -> None:
                if n == 0 or f.props.get("_SceneChangePrev") == 1:
                    iframe_list.append(n)

            clip_async_render(
                analysis_clip, outfile=None, progress=progress_func, callback=get_props
            )
            progress.update(
                task, description="[cyan]Scenes Analyzed         ", completed=nframe
            )

    with open(kf_file, "a") as file:
        file.write("\n".join(map(str, iframe_list)))

    with open(kf_file, "a") as file:
        file.write(f"\n{nframe}\n{fwidth}\n{fheight}\n{ffpsnum}\n{ffpsden}")

    return iframe_list, hr, nframe, fwidth, fheight, ffpsnum, ffpsden


def fast_pass() -> None:
    """
    Fast pass using native Av1an to generate an MKV file.
    """
    encoder_params = f"--preset {fast_speed} "

    # Check if CRF is manually specified in fast_params
    needs_crf = True
    if fast_params and "--crf" in fast_params:
        needs_crf = False

    if needs_crf:
        # Load VPY to check for HR content (High Resolution)
        try:
            vpy_vars = {}
            exec(open(vpy_file).read(), globals(), vpy_vars)
            src = vpy_vars["src"]
            hr = src.width * src.height > 1920 * 1080
        except Exception as e:
            if verbose:
                console.print(
                    f"[yellow]Warning: Could not determine resolution from VPY, defaulting hr=False. Error: {e}[/yellow]"
                )
            hr = False

        # Match CRF based on user quality setting
        match quality:
            case "low":
                crf = 40 if hr else 35
            case "medium":
                crf = 35 if hr else 30
            case "high":
                crf = 30 if hr else 25
            case "breeze":
                crf = 18 if hr else 18
            case _:
                crf = float(quality)

        encoder_params += f" --crf {crf} "

    if fast_params:
        encoder_params += f"{fast_params}"

    if verbose:
        console.print(f'Fast params: "{encoder_params}"')

    # Av1an command - Native
    av1an_cmd = [
        str(av1an_exe),
        "-i",
        vpy_file.name,  # Just the filename
        "-e",
        "svt-av1",
        "-c",
        "mkvmerge",
        "-w",
        "1",
        "-x",
        "0",
        "--resume",
        "--verbose",
        "--split-method",
        "none",
        "-v",
        encoder_params,
        "-o",
        fast_output_file.name,  # Just the filename
    ]

    print("-" * 50)
    print(f"Running Fast Pass (Native) in: {tmp_dir}")
    print(f"Command:\n{' '.join(av1an_cmd)}")
    print("-" * 50)

    try:
        # Run in tmp_dir so it picks up files from current dir
        subprocess.run(av1an_cmd, check=True, cwd=tmp_dir)
    except subprocess.CalledProcessError as e:
        console.print(f"[red]Fast pass failed:[/red]\n{e}")
        raise SystemExit(1)


def final_pass() -> None:
    """
    Final encoding pass using native Av1an.
    """
    if not scenes_file.exists() and not no_boosting:
        console.print("[red]Scenes file not found![/red]")
        raise SystemExit(1)

    av1an_cmd = [
        str(av1an_exe),
        "-i",
        vpy_file.name,  # Just the filename
        "-y",
        "--workers",
        str(av1an_workers),
        "--resume",
        "--no-defaults",
        "--keep",
        "--photon-noise",
        str(photon_noise_val),
        "-e",
        "svt-av1",
        "-o",
        tmp_final_output_file.name,  # Just the filename
    ]

    if not no_boosting:
        # Use generated scenes
        av1an_cmd.extend(["-s", scenes_file.name])
    else:
        v_params = f"--preset {final_speed} --crf {quality} {final_params}"
        av1an_cmd.extend(["-v", v_params])

    # Show command ALWAYS per user request
    print("-" * 50)
    print(f"Running Final Pass (Native) in: {tmp_dir}")
    print(f"Command:\n{' '.join(av1an_cmd)}")
    print("-" * 50)

    try:
        # Run in tmp_dir so it picks up files from current dir
        subprocess.run(av1an_cmd, check=True, cwd=tmp_dir)
    except subprocess.CalledProcessError as e:
        console.print(f"[red]Final pass failed:[/red]\n{e}")
        raise SystemExit(1)


def calculate_metric() -> None:
    # Import needed for parallelism
    import concurrent.futures

    # Use Windows VPY for source
    vpy_vars = {}
    exec(open(vpy_file).read(), globals(), vpy_vars)
    source_clip = vpy_vars["src"]

    # Read Fast Pass MKV
    try:
        if not fast_output_file.exists():
            console.print(
                "[red]Fast pass output file not found. Did the fast pass fail?[/red]"
            )
            raise SystemExit(1)
        encoded_clip = core.ffms2.Source(source=fast_output_file, cache=False)
    except Exception as e:
        console.print(f"[red]Error indexing fast pass file: {e}[/red]")
        raise SystemExit(1)

    if len(source_clip) != len(encoded_clip):
        console.print(
            f"[red]Frame count mismatch: Src {len(source_clip)} vs Enc {len(encoded_clip)}[/red]"
        )
        raise SystemExit(1)

    skip = 6
    cut_source_clip = source_clip[::skip]
    cut_encoded_clip = encoded_clip[::skip]

    global ssimu2
    if ssimu2 == "":
        try:
            result = core.vszip.XPSNR(
                cut_source_clip, cut_encoded_clip, temporal=False, verbose=False
            )
        except:
            console.print("[red]vs-zip not found/failed.[/red]")
            raise SystemExit(1)

        score_list = [[None] * cut_source_clip.num_frames for _ in range(3)]

        def get_xpsnrprops(n, f):
            for i, plane in enumerate(["Y", "U", "V"]):
                val = f.props.get(f"XPSNR_{plane}")
                score_list[i][n] = "100.0" if str(val) == "inf" else float(val)

        with Progress(SpinnerColumn(), BarColumn(), FPSColumn(), console=console) as p:
            task = p.add_task(
                "Calculating XPSNR", total=cut_source_clip.num_frames * skip
            )

            def update_p(n, t):
                p.update(task, advance=skip)

            clip_async_render(result, progress=update_p, callback=get_xpsnrprops)

        with open(xpsnr_log_file, "w") as file:
            skip_offset = 0
            for index in range(len(score_list[0])):
                for i in range(skip):
                    file.write(
                        f"{index + skip_offset + i}: {score_list[0][index]} {score_list[1][index]} {score_list[2][index]}\n"
                    )
                skip_offset += skip - 1

    else:
        # FSSIMU2 IMPLEMENTATION (PARALLEL) WITH FALLBACK
        if not fssimu2_exe.exists():
            console.print(
                f"[red]fssimu2 binary not found at {fssimu2_exe}! Cannot calculate metrics.[/red]"
            )
            raise SystemExit(1)

        # Convert to RGB24 for PAM export
        # Assume 709 matrix for HD content usually handled by this script
        ref_rgb = cut_source_clip.resize.Bicubic(format=vs.RGB24, matrix_in_s="709")
        dist_rgb = cut_encoded_clip.resize.Bicubic(format=vs.RGB24, matrix_in_s="709")

        score_list = [None] * ref_rgb.num_frames
        fallback_needed = False

        # Helper function to write PAM
        def write_pam(frame, filepath):
            width, height = frame.width, frame.height
            r = np.asarray(frame[0])
            g = np.asarray(frame[1])
            b = np.asarray(frame[2])
            packed = np.dstack((r, g, b)).tobytes()
            header = (
                f"P7\n"
                f"WIDTH {width}\n"
                f"HEIGHT {height}\n"
                f"DEPTH 3\n"
                f"MAXVAL 255\n"
                f"TUPLTYPE RGB\n"
                f"ENDHDR\n"
            ).encode()
            with open(filepath, "wb") as f:
                f.write(header)
                f.write(packed)

        # WORKER FUNCTION FOR PARALLEL EXECUTION
        def process_frame(n):
            if fallback_needed:
                return n, 0.0  # Abort

            # Request frames
            f_ref = ref_rgb.get_frame(n)
            f_dist = dist_rgb.get_frame(n)

            # Use UNIQUE paths per frame to prevent workers overwriting each other
            current_ref_path = tmp_dir / f"ref_{n}.pam"
            current_dist_path = tmp_dir / f"dist_{n}.pam"

            # Write Temp PAMs
            write_pam(f_ref, current_ref_path)
            write_pam(f_dist, current_dist_path)

            # Sanitize paths
            ref_str = str(current_ref_path).replace("\\\\?\\", "")
            dist_str = str(current_dist_path).replace("\\\\?\\", "")

            # Run fssimu2
            cmd = [str(fssimu2_exe), ref_str, dist_str]
            score = 0.0

            try:
                # shell=True is needed for Windows but can cause issues on Linux with list args behavior
                use_shell = platform.system() == "Windows"
                res = subprocess.run(
                    cmd, capture_output=True, text=True, check=True, shell=use_shell
                )

                output = res.stdout.strip()
                if not output:
                    if res.stderr.strip():
                        output = res.stderr.strip()

                score = float(output)

            except subprocess.CalledProcessError as e:
                console.print(f"[red]fssimu2 crashed at frame {n * skip}.[/red]")
                console.print(f"--- STDERR: {e.stderr}")
                raise RuntimeError("fssimu2_crash")

            except ValueError:
                console.print(
                    f"[red]fssimu2 returned invalid output at frame {n * skip}[/red]"
                )
                raise RuntimeError("fssimu2_invalid")

            # Cleanup temp PAMs
            try:
                current_ref_path.unlink(missing_ok=True)
                current_dist_path.unlink(missing_ok=True)
            except:
                pass

            return n, score

        # Execute Parallel Workers
        try:
            with Progress(
                SpinnerColumn(),
                BarColumn(),
                FPSColumn(),
                TimeRemainingColumn(),
                console=console,
            ) as p:
                task = p.add_task(
                    "Calculating SSIMULACRA2 (6 Workers)",
                    total=ref_rgb.num_frames * skip,
                )

                with concurrent.futures.ThreadPoolExecutor(max_workers=6) as executor:
                    future_to_frame = {
                        executor.submit(process_frame, n): n
                        for n in range(ref_rgb.num_frames)
                    }

                    for future in concurrent.futures.as_completed(future_to_frame):
                        try:
                            n, score = future.result()
                            score_list[n] = score
                            p.update(task, advance=skip)
                        except RuntimeError:
                            console.print(
                                "[red]Crash detected in worker! Stopping binary method and switching to fallback...[/red]"
                            )
                            fallback_needed = True
                            executor.shutdown(wait=False, cancel_futures=True)
                            break
        except Exception as e:
            console.print(
                f"[yellow]Exception during pool execution: {e}. Fallback triggered.[/yellow]"
            )
            fallback_needed = True

        # --- FALLBACK LOGIC ---
        if fallback_needed:
            console.print(
                "[yellow]Falling back to vs-zip SSIMULACRA2 (4 workers)...[/yellow]"
            )

            # Fallback uses VapourSynth's internal vs-zip plugin
            # Set thread count as requested
            core.num_threads = 4

            try:
                if not hasattr(core.vszip, "SSIMULACRA2"):
                    console.print(
                        "[red]Error: vs-zip does not support SSIMULACRA2 function. Cannot fallback.[/red]"
                    )
                    raise SystemExit(1)

                # FIX: Use vs.RGB24 (valid format ID) instead of vs.RGB (ColorFamily enum)
                # vs.RGB24 is 8-bit integer RGB (usually Packed, but widely supported)
                fallback_ref = cut_source_clip.resize.Bicubic(
                    format=vs.RGB24, matrix_in_s="709"
                )
                fallback_dist = cut_encoded_clip.resize.Bicubic(
                    format=vs.RGB24, matrix_in_s="709"
                )

                # Calculate metric using plugin
                result = core.vszip.SSIMULACRA2(fallback_ref, fallback_dist)

                score_list = [None] * cut_source_clip.num_frames

                def get_ssimprops(n, f):
                    # Try standard property first
                    val = f.props.get("_SSIMULACRA2")
                    # Try alternate property name just in case
                    if val is None:
                        val = f.props.get("SSIMULACRA2")
                    if val is None:
                        val = f.props.get("float_ssimulacra2")

                    if val is None:
                        if n == 0:
                            console.print(
                                "[red]Warning: _SSIMULACRA2 property missing in fallback frame 0[/red]"
                            )
                        score_list[n] = 0.0
                    else:
                        score_list[n] = float(val)

                with Progress(
                    SpinnerColumn(), BarColumn(), FPSColumn(), console=console
                ) as p:
                    task = p.add_task(
                        "Calculating SSIMULACRA2 (VS-ZIP Fallback)",
                        total=cut_source_clip.num_frames * skip,
                    )

                    def update_p(n, t):
                        p.update(task, advance=skip)

                    clip_async_render(result, progress=update_p, callback=get_ssimprops)
            except Exception as e:
                console.print(f"[red]Fallback failed: {e}[/red]")
                raise SystemExit(1)

        # Write log
        with open(ssimu2_log_file, "w") as file:
            skip_offset = 0
            for index, score in enumerate(score_list):
                final_score = score if score is not None else 0.0
                for i in range(skip):
                    file.write(f"{index + skip_offset + i}: {final_score}\n")
                skip_offset += skip - 1


def metrics_aggregation(score_list: list[float]) -> tuple[float, float, float]:
    filtered_score_list = [score if score >= 0 else 0.0 for score in score_list]
    sorted_score_list = sorted(filtered_score_list)

    if not sorted_score_list:
        return 0.0, 0.0, 0.0

    average = sum(filtered_score_list) / len(filtered_score_list)

    # Handle single-frame or extremely short scenes where quantiles fails (needs >=2 points)
    if len(sorted_score_list) < 2:
        return (average, sorted_score_list[0], sorted_score_list[0])

    percentile_15 = quantiles(sorted_score_list, n=100)[14]
    min_score = sorted_score_list[0]
    return (average, percentile_15, min_score)


# --- ZONES HELPERS ---


def find_zones_file(video_path: Path) -> Path | None:
    """
    Looks for a zones file matching sXXeXX pattern.
    Example: Awesome.Show.S01E02.mkv matches s01e02-zones.txt
    """
    stem = video_path.stem
    # Match S01E02 or s01e02 case insensitive
    match = re.search(r"([sS]\d{2}[eE]\d{2})", stem)
    if not match:
        return None

    ep_str = match.group(1).lower()
    zones_filename = f"{ep_str}-zones.txt"
    zones_path = video_path.parent / zones_filename

    if zones_path.exists():
        return zones_path
    return None


def parse_param_string_to_dict(param_list: list[str]) -> dict:
    """
    Converts a list of params ['--crf', '20', '--enable-cdef', '1']
    into a dict {'--crf': '20', '--enable-cdef': '1'}.
    Handles boolean flags (no value) if necessary, though SVT usually has values.
    """
    d = {}
    i = 0
    while i < len(param_list):
        key = param_list[i]
        if key.startswith("--"):
            # Check if next item exists and is not a flag
            if i + 1 < len(param_list) and not param_list[i + 1].startswith("--"):
                d[key] = param_list[i + 1]
                i += 2
            else:
                # Boolean flag or flag at end
                d[key] = None
                i += 1
        else:
            # stray value? ignore
            i += 1
    return d


def dict_to_param_list(d: dict) -> list[str]:
    l = []
    for k, v in d.items():
        l.append(k)
        if v is not None:
            l.append(v)
    return l


def merge_params(
    base_params: list[str], zone_params_str: str
) -> tuple[list[str], int | None]:
    """
    Merges base params with zone params.
    Returns (new_param_list, photon_noise_override).
    """
    base_dict = parse_param_string_to_dict(base_params)

    # Split zone params string into list
    zone_list = zone_params_str.strip().split()
    zone_dict = parse_param_string_to_dict(zone_list)

    photon_noise_val = None

    # Update base with zone
    for k, v in zone_dict.items():
        if k == "--photon-noise":
            try:
                photon_noise_val = int(v)
            except:
                pass
            # Do not add photon noise to video_params dict
        else:
            base_dict[k] = v

    # Reconstruct list
    return dict_to_param_list(base_dict), photon_noise_val


# ---------------------


def calculate_zones_json(ranges: list[float], hr: bool, nframe: int) -> None:
    metric_scores = []

    if ssimu2 == "":
        with open(xpsnr_log_file, "r") as file:
            for line in file:
                match = re.search(
                    r"([0-9]+): ([0-9]+\.[0-9]+) ([0-9]+\.[0-9]+) ([0-9]+\.[0-9]+)",
                    line,
                )
                if match:
                    score_y, score_u, score_v = (
                        float(match.group(2)),
                        float(match.group(3)),
                        float(match.group(4)),
                    )
                    maxval = 255
                    w_mse = (
                        (4 * (maxval**2 / (10 ** (score_y / 10))))
                        + (maxval**2 / (10 ** (score_u / 10)))
                        + (maxval**2 / (10 ** (score_v / 10)))
                    ) / 6
                    metric_scores.append(10 * log10((maxval**2) / w_mse))
    else:
        with open(ssimu2_log_file, "r") as file:
            for line in file:
                # UPDATED REGEX: Matches integers, floats (0.98), scientific notation (1.23e-05)
                # This guarantees we catch whatever format python wrote to the file
                match = re.search(r"([0-9]+): (-?[0-9eE\.\-\+]+)", line)
                if match:
                    metric_scores.append(float(match.group(2)))

    metric_total_scores = []
    metric_percentile_15_total = []

    for index in range(len(ranges)):
        metric_chunk_scores = []
        if index == len(ranges) - 1:
            metric_frames = nframe - ranges[index]
        else:
            metric_frames = ranges[index + 1] - ranges[index]

        for scene_index in range(metric_frames):
            try:
                metric_score = metric_scores[ranges[index] + scene_index]
                metric_chunk_scores.append(metric_score)
                metric_total_scores.append(metric_score)
            except IndexError:
                pass

        if metric_chunk_scores:
            (metric_average, metric_percentile_15, _) = metrics_aggregation(
                metric_chunk_scores
            )
            metric_percentile_15_total.append(metric_percentile_15)
        else:
            metric_percentile_15_total.append(0)

    (metric_average, _, _) = metrics_aggregation(metric_total_scores)

    match quality:
        case "low":
            crf = 40 if hr else 35
        case "medium":
            crf = 35 if hr else 30
        case "high":
            crf = 30 if hr else 25
        case "breeze":
            crf = 18 if hr else 18
        case _:
            crf = float(quality)

    # 1. Generate Base Auto-Boost Scenes
    base_scenes = []

    for index in range(len(ranges)):
        multiplier = 40 if aggressive else 20
        if metric_average == 0:
            metric_average = 1

        adjustment = (
            ceil(
                (1.0 - (metric_percentile_15_total[index] / metric_average))
                * multiplier
                * 4
            )
            / 4
        )
        new_crf = crf - adjustment

        limit = 10 if unshackle else 5
        if adjustment < -limit:
            new_crf = crf + limit
        elif adjustment > limit:
            new_crf = crf - limit

        start_frame = ranges[index]
        if index == len(ranges) - 1:
            end_frame = nframe
        else:
            end_frame = ranges[index + 1]

        if verbose:
            console.print(
                f"Chunk: [{start_frame}:{end_frame}] / 15th: {metric_percentile_15_total[index]:.2f} / CRF: {new_crf}"
            )

        extra_params = final_params.split() if final_params else []
        scene_params = [
            "--preset",
            final_speed,
            "--crf",
            f"{new_crf:.2f}",
        ] + extra_params

        base_scenes.append(
            {
                "start_frame": start_frame,
                "end_frame": end_frame,
                "photon_noise": photon_noise_val,  # Use global argument
                "video_params": scene_params,
            }
        )

    # 2. Check for Zones File
    zones_file = find_zones_file(src_file)
    final_scenes = base_scenes

    if zones_file:
        console.print(f"[green]Zones file found: {zones_file.name}[/green]")
        console.print("[yellow]Applying zones overrides...[/yellow]")

        # Read zones
        zones = []
        with open(zones_file, "r") as f:
            for line in f:
                if not line.strip() or line.strip().startswith("#"):
                    continue
                parts = line.split(maxsplit=3)  # start, end, enc, params
                if len(parts) < 4:
                    continue
                try:
                    z_start = int(parts[0])
                    z_end_raw = int(parts[1])

                    # Handle -1 as final frame
                    if z_end_raw == -1:
                        z_end = nframe - 1
                    else:
                        z_end = z_end_raw

                    # parts[2] is encoder (ignored mostly), parts[3] is params
                    z_params = parts[3]
                    zones.append((z_start, z_end, z_params))
                except ValueError:
                    console.print(f"[red]Invalid zone line: {line.strip()}[/red]")

        # Apply zones iteratively (Cookie Cutter)
        for z_start, z_end, z_params_str in zones:
            new_list = []

            # z_end in zones.txt is typically inclusive in user intent
            # e.g., "0 270" includes frame 270.
            # Av1an internal scene logic is usually [Start, End) (exclusive end)
            # So the scene logic split point should be z_end + 1

            z_end_exclusive = z_end + 1

            for scene in final_scenes:
                s_start = scene["start_frame"]
                s_end = scene["end_frame"]

                # Check for overlap
                # Overlap if: start1 < end2 AND start2 < end1
                if s_start < z_end_exclusive and z_start < s_end:
                    # Overlap exists. We might need to split into 3 parts:
                    # 1. Pre-zone (Original)
                    # 2. Zone (Modified)
                    # 3. Post-zone (Original)

                    # 1. Pre-zone
                    if s_start < z_start:
                        new_list.append(
                            {
                                "start_frame": s_start,
                                "end_frame": z_start,
                                "photon_noise": scene["photon_noise"],
                                "video_params": scene["video_params"],
                            }
                        )

                    # 2. Zone Intersection
                    # Intersection start: max(s_start, z_start)
                    # Intersection end: min(s_end, z_end_exclusive)
                    int_start = max(s_start, z_start)
                    int_end = min(s_end, z_end_exclusive)

                    # Merge params
                    merged_params, merged_pn = merge_params(
                        scene["video_params"], z_params_str
                    )
                    pn = merged_pn if merged_pn is not None else scene["photon_noise"]

                    new_list.append(
                        {
                            "start_frame": int_start,
                            "end_frame": int_end,
                            "photon_noise": pn,
                            "video_params": merged_params,
                        }
                    )

                    # 3. Post-zone
                    if s_end > z_end_exclusive:
                        new_list.append(
                            {
                                "start_frame": z_end_exclusive,
                                "end_frame": s_end,
                                "photon_noise": scene["photon_noise"],
                                "video_params": scene["video_params"],
                            }
                        )

                else:
                    # No overlap, keep original
                    new_list.append(scene)

            final_scenes = new_list
            # Sort by start frame to be safe
            final_scenes.sort(key=lambda x: x["start_frame"])

    # 3. Construct Final JSON
    scenes_data_output = []
    for s in final_scenes:
        scenes_data_output.append(
            {
                "start_frame": s["start_frame"],
                "end_frame": s["end_frame"],
                "zone_overrides": {
                    "encoder": "svt_av1",
                    "passes": 1,
                    "video_params": s["video_params"],
                    "photon_noise": s["photon_noise"],
                    "photon_noise_height": None,
                    "photon_noise_width": None,
                    "chroma_noise": False,
                    "extra_splits_len": 240,
                    "min_scene_len": 24,
                },
            }
        )

    output_json = {"frames": nframe, "scenes": scenes_data_output}

    with open(scenes_file, "w") as f:
        json.dump(output_json, f, indent=2)

    console.print(f"[cyan]Generated Av1an scenes file: {scenes_file}[/cyan]")


console.print("[bold]Auto-boost (Native-Av1an + fssimu2) start!\n")

if no_boosting:
    stage = 4

match stage:
    case 0:
        if stage_resume < 2:
            fast_pass()
            with open(stage_file, "w") as file:
                file.write("2")
            print("Stage 1 complete! Now calculating metric scores")
        if stage_resume < 3:
            try:
                calculate_metric()
            except KeyboardInterrupt:
                raise SystemExit(1)
            with open(stage_file, "w") as file:
                file.write("3")
            print("Stage 2 complete!")
        if stage_resume < 4:
            try:
                ranges, hr, nframe, _, _, _, _ = get_file_info(src_file, "src")
                calculate_zones_json(ranges, hr, nframe)
            except KeyboardInterrupt:
                raise SystemExit(1)
            with open(stage_file, "w") as file:
                file.write("4")
            print("Stage 3 complete!")
        if stage_resume < 5:
            final_pass()
            shutil.move(tmp_final_output_file, final_output_file)
            with open(stage_file, "w") as file:
                file.write("5")
            print("Stage 4 complete!")
    case 1:
        fast_pass()
        with open(stage_file, "w") as file:
            file.write("2")
        print("Stage 1 complete! Now calculating metric scores")
    case 2:
        try:
            calculate_metric()
        except KeyboardInterrupt:
            raise SystemExit(1)
        with open(stage_file, "w") as file:
            file.write("3")
        print("Stage 2 complete!")
    case 3:
        try:
            ranges, hr, nframe, _, _, _, _ = get_file_info(src_file, "src")
            calculate_zones_json(ranges, hr, nframe)
        except KeyboardInterrupt:
            raise SystemExit(1)
        with open(stage_file, "w") as file:
            file.write("4")
        print("Stage 3 complete!")
    case 4:
        final_pass()
        shutil.move(tmp_final_output_file, final_output_file)
        with open(stage_file, "w") as file:
            file.write("5")
        print("Stage 4 complete!")
    case _:
        console.print("[red]Stage argument invalid, exiting.")
        raise SystemExit(1)

console.print("\n[bold]Auto-boost complete!")
